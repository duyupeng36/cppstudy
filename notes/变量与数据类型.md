---
aliases:
  - variables
  - data-types
cssclasses:
  - variables
  - data-types
tags:
  - cpp
  - cpp/variables
  - cpp/data-types
summary: 变量与 C++ 中的预定义类型
---
# 变量与数据类型

现在，我们需要明确一个事实：程序中使用的数据，以及程序本身在计算机内存中都是使用 $0$ 和 $1$ 的序列来表示的；换句话说，**计算机内存只能存储 $0$ 和 $1$**。如下图所示

![image.png|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1757512655439-4ac7e9290d5e46d0ab2d489887337524.png)

这些单纯的 $0$ 和 $1$ 的序列对于我们而言并无任何作用，因此需要一种概念表示定义 $0$ 和 $1$ 的序列，并存储对我们有意义的数据。

> [!hint] 
> 请注意：单纯的一个 $0$ 或 $1$ 都被称为一个 **比特(bit)**。因此，这种由 $0$ 和 $1$ 组成的序列被称为 **位序列** 或者**位模式** 或者 **位向量**。

然而，位模式的概念并没有多大的作用，我们还是不清楚这些位模式存储的是什么样的数据。为了让位模式有更好的含义，一个好的想法就是 **限制位模式的长度**。例如，将 $8$ 个比特位组合在一起称为长度位 $8$ 的位模式，或者更通用的称为 **字节**

现代计算机中，**对内存的操作的最小单位就是字节**，通过对字节的组合可以定义更多的概念。例如，我们将 $1024$ 个字节组合在一起，就称为 **千字节(Kilobytes, KB)**；将 $1024$ 个千字节组合在一起，就称为 **兆字节(Megabytes, MB)**。下表列出了常见的内存单位

| 单位        | 描述                |
| :-------- | :---------------- |
| `bit, b`  | 单纯的一个 $0$ 或 $1$   |
| `byte, B` | `1byte = 8bits`   |
| `KB`      | `1KB = 1024bytes` |
| `MB`      | `1MB = 1024KB`    |
| `GB`      | `1GB = 1024MB`    |
| `TB`      | `1TB = 1024GB`    |
| `PB`      | `1PB = 1024TB`    |
| `EB`      | `1EB = 1024PB`    |
| ....      |                   |

> [!tip] 
> 请注意，在内存单位中，`b` 代表 `bit`；而 `B` 代表 `byte`

到目前为止，我们知道了各种长度的位模式；但是，尚不清楚这些位模式表示的是什么类型的数据。例如，下图中的位模式 `01101110`，在我们不清楚其 **类型** 之前，它仅仅只是一串 $0$ 和 $1$ 组成的序列。如果赋予其确定的类型，该位模式才会有意义

![image.png|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1757514595518-34c9dabae7e045d4b62465ef9e80a1dd.png)

> [!tip] 
> **类型**：赋予位模式某种概念；即位模式表示的是什么样数据，以及能够在该数据上的操作
> + 例如，位模式 `01101110` 的类型是整数，则该位模式表示的就是整数 $110$。

计算机采用位模式的形式存储数据，因此必须定义一个良好的系统将不同类型的数据转换位位模式，并且能够从位模式中还原原始类型的数据。下面将要介绍的 **数字系统** 就将 **位模式** 与 **人类可读的数字** 的之间进行转换的规则

## 数字系统

数字系统允许我们将数据从人类友好的形式转换为计算机友好的形式；也可以从计算机友好的形式转换为人类友好的形式。

目前，常用的数字系统是 **位置化数字系统**，即 **数字中符号所占据的位置诀定了其表示的值**。最常用的位置数字系统有 $4$ 种，分别为 **十进制**、**二进制**、**八进制**、**十六进制**。下面我们就从最常用的 **十进制** 开始

在十进制数字系统中，使用 $\{0, 1, 2, 3, 4, 5, 6, 7, 8, 9\}$ 共计 $10$ 个符号表示数字。当数符 $k$ 出现在位置 $n$ 处时，其值为 $k \times 10^n$。下图展示了十进制数字系统表示的值

![image.png|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1757516639045-cdc3005e6a234a068975502636b3c6ec.png)

### 二进制

在二进制数字系统中，使用 $\{0, 1\}$ 共计 $2$ 个符号表示数字。当数符 $k$ 出现在位置 $n$ 处时，其值为 $k \times 2^n$。下图展示了二进制数字系统的表示以及其对应的十进制值的计算方式

![image.png|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1757517021836-a07a2fa833e7467f944fc847a5740108.png)

回忆一下，之前我们介绍的 $n$ 位位模式。下表列出了不同长度位模式能够表示的数字范围

| $3$ 位位模式 | 值       |     | $4$ 位位模式 | 值       |     | $5$ 位位模式 | 值       |
| :------- | :------ | :-- | -------- | ------- | --- | -------- | ------- |
| `000`    | `0`     |     | `0000`   | `0`     |     | `00000`  | `0`     |
| `001`    | `1`     |     | `0001`   | `1`     |     | `00001`  | `1`     |
| `010`    | `2`     |     | `0010`   | `2`     |     | `00010`  | `2`     |
| `011`    | `3`     |     | `0011`   | `3`     |     | `00011`  | `3`     |
| `100`    | `4`     |     | `0100`   | `4`     |     | `00100`  | `4`     |
| `101`    | `5`     |     | `0101`   | `5`     |     | `00101`  | `5`     |
| `110`    | `6`     |     | `0110`   | `6`     |     | `00110`  | `6`     |
| `111`    | `7`     |     | `0111`   | `7`     |     | `00111`  | `7`     |
|          | $2^3-1$ |     | `1000`   | `8`     |     | `01000`  | `8`     |
|          |         |     | `1001`   | `9`     |     | `01001`  | `9`     |
|          |         |     | `1010`   | `10`    |     | `01010`  | `10`    |
|          |         |     | `1011`   | `11`    |     | `01011`  | `11`    |
|          |         |     | `1100`   | `12`    |     | `01100`  | `12`    |
|          |         |     | `1101`   | `13`    |     | `01101`  | `13`    |
|          |         |     | `1110`   | `14`    |     | `01110`  | `14`    |
|          |         |     | `1111`   | `15`    |     | `01111`  | `16`    |
|          |         |     |          | $2^4-1$ |     | `....`   | `....`  |
|          |         |     |          |         |     | `11111`  | `31`    |
|          |         |     |          |         |     |          | $2^5-1$ |

> [!tip] 
> 通过计算，我们得出 $n$ 位位模式可以表示的值的范围 $0 \sim 2^n-1$

二进制数字系统用于计算机存储数据，但是不能方便的在计算机外部表示数字，因为使用二进制系统表示的数字太长了。十进制系统不能直接显示存储在计算机中的是什么。为克服这个两个问题，发明了 **十六进制数字系统** 和 **八进制数字系统**

### 十六进制


在十六进制系统中，使用 $\{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F\}$ 共计 $16$ 个符号表示数字。下图展示了十六进制数字系统的表示以及其对应的十进制值的计算方式

![image.png|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1757518527856-d1afc156e9f64cb68c5b99b2475eb65d.png)

### 八进制

在八进制系统中，使用 $\{0, 1, 2, 3, 4, 5, 6, 7\}$ 共计 $8$ 个符号表示数字。下图展示了八进制数字系统的表示以及其对应的十进制值的计算方式

![image.png|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1757518847452-b5cae96c65384142af37d8c492ef4751.png)


回顾一下，我们在计算 $3$ 位位模式和 $4$ 位位模式的能够表示的值时列出的表格

| 二进制   | 十进制值 | 八进制 |     | 二进制    | 十进制值 | 十六进制 |
| :---- | :--- | :-- | :-- | ------ | ---- | ---- |
| `000` | `0`  | `0` |     | `0000` | `0`  | `0`  |
| `001` | `1`  | `1` |     | `0001` | `1`  | `1`  |
| `010` | `2`  | `2` |     | `0010` | `2`  | `2`  |
| `011` | `3`  | `3` |     | `0011` | `3`  | `3`  |
| `100` | `4`  | `4` |     | `0100` | `4`  | `4`  |
| `101` | `5`  | `5` |     | `0101` | `5`  | `5`  |
| `110` | `6`  | `6` |     | `0110` | `6`  | `6`  |
| `111` | `7`  | `7` |     | `0111` | `7`  | `7`  |
|       |      |     |     | `1000` | `8`  | `8`  |
|       |      |     |     | `1001` | `9`  | `9`  |
|       |      |     |     | `1010` | `10` | `A`  |
|       |      |     |     | `1011` | `11` | `B`  |
|       |      |     |     | `1100` | `12` | `C`  |
|       |      |     |     | `1101` | `13` | `D`  |
|       |      |     |     | `1110` | `14` | `E`  |
|       |      |     |     | `1111` | `15` | `F`  |

> [!hint] 二进制-八进制-十六进制之间的关系如下
> +  $4$ 位二进制数字恰好对应 $1$ 位十六进制数字
> + $3$ 位二进制数字恰好对应 $1$ 位八进制数字

下图演示演示 **八进制-二进制-十六进制** 之间的相互转换。

![image.png|800](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1757520185270-79a5a520ba99461293f26384f6c627ef.png)

在 C++ 程序中如何使用它们呢？下面的示例程序演示了如何在 C++ 中使用不同的数字系统表示数字 $15$ 

```cpp
#include <iostream>

int main() {

    int number1 = 15; // 十进制
    int number2 = 017; // 八进制
    int number3 = 0x0F; // 十六进制
    int number4 = 0b00001111; // 二进制 C++14 起支持
    std::cout << "number1: " << number1 << std::endl;
    std::cout << "number2: " << number2 << std::endl;
    std::cout << "number3: " << number3 << std::endl;
    std::cout << "number4: " << number4 << std::endl;
    return 0;
}
```

编译运行上述程序，输出的结果如下图

![image.png|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1757522563634-ddbafd2be46c49c28b283199f705dfbf.png)


## 变量

**对象** 是可以在其中 **保存值的一块存储区域**。执行环境中的 **对象** 中的内容可用于表示值。 当对象被引用时，可以具有特定的类型。下面介绍的 **变量** 就是对象的是个示例

变量本质上就是一块命名的 **数据存储区域**，其中存储的 **位模式** 可用于表示值。变量被引用时，会根据特定的 **类型** 解释位模式的含义

> [!tip] **类型** 决定了存储区域的尺寸和其存储的位模式的含义
> 
> 类型决定了存储区域的 **尺寸**，以及其中存储的 **位模式表示的内容**
> 

如何引用一个变量呢？C++(大部分语言)中采用 **变量名** 引用一块内存区域(对象)。下图形象的演示了一个变量的概念

![image.png|600](http://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1755701028908-7ea8e39e6b714242932d5ac139e2edb1.png)

**变量在被引用之前要先进行声明** 。在 C++ 中，声明一个变量的语法如下

```cpp
<类型> <变量名>[{初始值}] [, <变量名>[{初始值}], ...];
```

> [!attention] 
> 请注意：被方括号(`[]`)包围起来的内容是可以省略的。

### 命名规则

在 C++ 中，通过名字引用对象。C++ 标准限制了程序员如何命名对象。这里，我们会只介绍变量名的命名规则。其他对象的命名规则后续介绍

> [!tip] 
> 在命名变量时，只能使用 **英文字母**、 **数字** 和 **下划线**。并且，**数字不能作为名字的第一个字符**
> 
> 对于需要使用 **多词** 命名的对象，采用下划线分隔每个单词
> 
> 此外，**禁止使用 C++ 关键字命名对象**。C++ 关键字是编译器使用的名字，不允许将关键字作为其他用途

### 初始化

当变量被声明时，我们应该为变量提供一个初始值；即，变量存储的初始位模式。C++ 提供了 $3$ 种初始化语法
+ 初始化列表
+ 函数式初始化
+ C风格初始化

> [!attention] 
> 对于函数式初始化和 C风格初始化，在现代 C++ 开发中就不推荐使用了。我们也不做任何讲解 

如下代码片段展示 C++ 中的初始化列表初始化器

```cpp
#include <iostream>


int main() {
    int number1;    // 未初始化
    int number2{};  // 初始化为 0
    int number3{9};  // 初始化为 9
    int number4{10};  // 初始化为 10
    int number5{number3 + number4};  // 表达式

    std::cout << number1 << std::endl;
    std::cout << number2 << std::endl;
    std::cout << number3 << std::endl;
    std::cout << number4 << std::endl;
    std::cout << number5 << std::endl;
    return 0;
}
```

初始化列表会保证不执行 **窄化类型转换**。所谓的窄化类型转换就是会使得转换后的值小于原始值的类型转换

```cpp
int number6{2.9}; // 编译错误：{} 初始化时 C++ 编译器禁止此类转换
```

## 类型

下面我们正式介绍 C++ 中的数据类型。C++ 提供了 $3$ 中基本类型
+ 整数类型
+ 浮点数类型
+ 布尔类型
+ 字符类型

> [!tip] 
> 在 C++ 中，字符类型本质上就是整数类型 

### 整数

C++ 标准中，整数类型使用关键字 `int`  表示。`int` 类型的变量用于存储整数，例如 `9` `102` `3483` `-978` 等等。`int` 类型在大多数 C++ 实现中都占用 $4$ 字节的内存，即是 $32$ 位

> [!tip] 
> 也就是说，`int` 类型的变量中存储的位模式的长度为 $32$。

---

请注意：在我们给出的整数示例中出现了一个负数。我们知道计算机中只能存储 $0$ 或 $1$ 组成位模式，那么位模式是如何表示负数的呢？对于一个位模式，如果其表示的是一个 **有符号整数**，现代计算机中通常使用 **补码编码** 的规则解释这个位模式。

$$
B2T_n(\vec{w}) =-w_{n-1} \times 2^{n-1} + \sum_{i=0}^{n-2}w_{i}\times2^{i}
$$

其中 $\vec{w} = \left[w_{n-1}, w_{n-2}, \cdots, w_2, w_1, w_0\right], w_i \in \{0, 1\}$；$B$ 表示二进制，$T$ 表示补码，$2$ 表示 `to`(转换的意识)。

> [!tip] 
> 也就是说，长度为 $n$ 的位模式的 **最高位** (最左边的位)的取值决定了该位模式表示整数的符号
> + 如果 $w_{n-1} = 0$，则该位模式表示的是非负整数
> + 如果 $w_{n-1} = 1$，则该位模式表示的是负整数

> [!hint] 
> 对于长度为 $n$ 的位模式，采用补码编码规则解释时，其可以表示的整数范围为
> 
> **最大值**：
> 位模式的每一位取值为 $w_{n-1} = 0, w_{i}=1, i=0,1,2, \cdots, n-2$ 时，即 $\left[0, 1, 1, \cdots, 1, 1\right]$ ，该位模式的补码编码的整数值最大。最大值为 $B2T_n(\left[0, 1, 1, \cdots, 1, 1\right]) = 2^{n-1}-1$
> 
> **最小值**
> 位模式的每一位取值为 $w_{n-1}=1, w_{i}=0, i=0, 1, 2, \cdots, n-2$ 时，及 $\left[1, 0, 0, \cdots, 0\right]$，该位模式的补码编码的整数值最小。最小值为 $B2T_{n}(\left[1, 0, 0, \cdots, 0, 0\right]) = 2^{n-1}$

---

有时候，在我们的可能 **不需要使用负数**，如果此时还采用 **补码编码** 规则，会导致位模式的浪费。因此，对于不需要使用负数的场景，即 **无符号整数** ，现代计算机中通常使用 **无符号编码** 的规则解释这个位模式

$$
B2U_n(\vec{w}) =\sum_{i=0}^{n-1}w_{i}\times2^{i}
$$

其中 $\vec{w} = \left[w_{n-1}, w_{n-2}, \cdots, w_2, w_1, w_0\right], w_i \in \{0, 1\}$ 表示位向量；$B$ 表示二进制，$U$ 表示无符号数，$2$ 表示 `to`(转换的意识)。

> [!hint] 
> 对于长度为 $n$ 的位模式，采用无符号编码规则解释时，其可以表示的整数范围为
> 
> **最大值**：
> 位模式的每一位取值为 $w_{i}=1, i=0,1,2, \cdots, n-1$ 时，即 $\left[1, 1, 1, \cdots, 1, 1\right]$ ，该位模式的补码编码的整数值最大。最大值为 $B2U_n(\left[1, 1, 1, \cdots, 1, 1\right]) = 2^{n}-1$
> 
> **最小值**
> 位模式的每一位取值为 $w_{i}=0, i=0, 1, 2, \cdots, n-1$ 时，及 $\left[0, 0, 0, \cdots, 0\right]$，该位模式的无符号编码的整数值最小。最小值为 $B2U_{n}(\left[0, 0, 0, \cdots, 0, 0\right]) = 0$

---

默认情况下， 在 C++ 标准中的 `int` 类型通常是 **有符号整数**。即，当引用 `int` 类型的变量时，将采用补码编码规则解释该变量中存储的位模式。此时，在大多数 C++ 实现中，`int` 类型存储的位模式的长度通常是 $32$ 位(即 $4$ 字节) 。

有的时候，我们可能并不需要 $32$ 位长度位模式来表示整数，也可能需要更长的位模式来表示整数，甚至可能不需要负数。因此，C++ 标准提供了下表列出的几个修饰符用于控制 `int` 类型的行为

| 整数修饰符      | 描述               |
| :--------- | :--------------- |
| `short`    | 限定尺寸不高于 `int`    |
| `long`     | 限定尺寸不低于 `int`    |
| `unsigned` | 限定无无符号整数         |
| `signed`   | 限定为有符号整数(**默认**) |

> [!tip] 
> 默认情况下，`int` 类型用于存储有符号正整数。也就是说 `signed int` 和 `int` 是同一个类型

在 C++ 中大部分实现中，`short int` 占用 $16$ 位(即 $2$ 字节)的内存；`long int` 占用 $64$ 位($8$ 字节)的内存。此外，C++ 标准规定了 `long long int`，它占用的内存至少与 `long int` 相当。

下表总结了所有的整数类型，并给出了它们在大部分实现中占用的内存大小

| 类型                       | $64$ 位 | 范围                    | $32$ 位 | 范围                    |
| :----------------------- | :----- | :-------------------- | ------ | --------------------- |
| `short int`              | $16$ 位 | $[-2^{15}, 2^{15}-1]$ | $16$ 位 | $[-2^{15}, 2^{15}-1]$ |
| `unsigned short int`     | $16$ 位 | $[0, 2^{16}-1]$       | $16$ 位 | $[0, 2^{16}-1]$       |
| `int`                    | $32$ 位 | $[-2^{31}, 2^{31}-1]$ | $16$ 位 | $[-2^{15}, 2^{15}-1]$ |
| `unsigned int`           | $32$ 位 | $[0, 2^{32}-1]$       | $16$ 位 | $[0, 2^{16}-1]$       |
| `long int`               | $64$ 位 | $[-2^{63}, 2^{63}-1]$ | $32$ 位 | $[-2^{31}, 2^{31}-1]$ |
| `unsigned long int`      | $64$ 位 | $[0, 2^{64}-1]$       | $32$ 位 | $[-2^{31}, 2^{31}-1]$ |
| `long long int`          | $64$ 位 |                       | $64$ 位 | $[-2^{63}, 2^{63}-1]$ |
| `unsigned long long int` | $64$ 位 |                       | $64$ 位 | $[0, 2^{64}-1]$       |

> [!attention] 
> 请注意，C++ 标准对 `int` `long int` `long long int` 占用的内存大小有要求的
> + `int` 类型的尺寸必须 $\ge 16$ 位
> + `long` 类型的尺寸必须 $\ge 32$ 位
> + `long long` 类型的尺寸必须 $\ge 64$ 位
> 
> 通常，在 $64$ 位平台上，`int` 类型占用 $32$ 位；`long int` 类型占用 $64$ 位。然而，在 $32$ 位平台上，`int` 类型占用 $16$ 位；`long int` 类型占用 $32$ 位  

下面的代码用于验证之前介绍的整数类型的尺寸和范围

```cpp
#include <iostream>

int main() {
    
    // Type: int
    int value1{10};
    int value2{-20};
    std::cout << "value1 : " << value1 << std::endl;
    std::cout << "value2 : " << value2 << std::endl;

    // Type: signed int
    signed int value3{10};
    signed int value4{-20};
    std::cout << "value3 : " << value3 << std::endl;
    std::cout << "value4 : " << value4 << std::endl;
    
    // Type: unsigned int
    unsigned int value5{10};
    // unsigned int value6{-20};  
    // 编译错误：窄化转换，转换后的目标值与原始值不相等，即是精度丢失
    unsigned int value6 = -20; // c 风格初始化。
    unsigned int value7(-20);  // 函数式初始化。容易与函数声明混淆
    std::cout << "value5 : " << value5 << std::endl;
    std::cout << "value6 : " << value6 << std::endl;
    std::cout << "value7 : " << value7 << std::endl;

    // sizeof(Type)
    std::cout << "sizeof(short int): " << sizeof(short int) << std::endl;
    std::cout << "sizeof(int): " << sizeof(int) << std::endl;
    std::cout << "sizeof(long int): " << sizeof(long int) << std::endl;
    std::cout << "sizeof(long long int): " << sizeof(long long int) << std::endl;

    return 0;
}
```

上述代码在 x86-64 机器上编译执行的结果为

```shell
value1 : 10
value2 : -20
value3 : 10
value4 : -20
value5 : 10
value6 : 4294967276
value7 : 4294967276
sizeof(short int): 2
sizeof(int): 4
sizeof(long int): 8
sizeof(long long int): 8
```

### 浮点数

有些时候需要变量能存储 **带小数点的数**，或者能存储 **极大数** 或 **极小数**；例如 `3.10` `0.000000378`。我们知道任何数据在计算机中都是使用位模式存储的，那么浮点数又是怎样存储的呢？浮点数通常是按照 [IEEE 754 标准](https://en.wikipedia.org/wiki/IEEE_754) 存储在计算机内存中。下面我们详细介绍这该标准




C++ 提供了  种浮点类型，对应三种不同的浮点格式。它们分别是  `float`、`double` 以及 `long double` 类型用于存储浮点数。

其中，`double` 类型是存储浮点数的默认类型。下表列出了这 $3$ 个浮点数类型占用的内存大小以及表示浮点数的精度

| 类型            | 尺寸        | 精度         |
| :------------ | :-------- | :--------- |
| `float`       | $32$ 位    | $7$ 位有效数字  |
| `double`      | $64$ 位    | $7$ 位有效数字  |
| `long double` | 至少 $64$ 位 | $>15$ 有效数字 |

> [!tip] 
> 精度是指浮点数的有效数字，即从第一个不为零的数字开始计数。
> 
> 请注意：`double` 和 `long double` 可能是一样的，取决于我们使用的编译器

```cpp
#include <iostream>
#include <iomanip>


int main() {
    float f{1.12345678901234567890f};
    double d{1.12345678901234567890};
    long double ld{1.12345678901234567890L};

    std::cout << "sizeof(float): " << sizeof(float) << std::endl;
    std::cout << "sizeof(double): " << sizeof(double) << std::endl;
    std::cout << "sizeof(long double): " << sizeof(long double) << std::endl;

    std::cout << std::setprecision(20);  // 设置输出浮点数时输出 20位
    std::cout << "f = " << f << std::endl;  // 1.123456<8357467651367>
    std::cout << "d = " << d << std::endl;  // 1.1234567890123456<912>
    std::cout << "ld = " << ld << std::endl; // 1.1234567890123456789

    return 0;
}
```

上述代码编译运行的结果如下

```shell
sizeof(float): 4
sizeof(double): 8
sizeof(long double): 16
f = 1.1234568357467651367
d = 1.1234567890123456912
ld = 1.1234567890123456789
```

请注意 `f` 的结果。在第一个 `123456` 之后本应该出现 `7` 然而却出现了 `8`，这就是精度损失导致的。同理，注意 `d` 的结果，也出现了不是我们赋予的初始值的情形。

> [!attention] 
> 如果向浮点数类型的变量存储超出该类型的精度要求的浮点数，这会导致我们得到错误的的结果





